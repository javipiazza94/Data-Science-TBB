using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using OpenQA.Selenium;
using OpenQA.Selenium.Support.UI;
using System.Threading;
using OpenQA.Selenium.Interactions;
using AntiCaptcha.Api;
using System.Net;
using Selenium.CI.Core.BusinessLogic;
using System.Collections.ObjectModel;
using AShotNet.ScreenTaker;

namespace Selenium.CI.Core.Labyrinth
{
    /// <summary>
    /// This class represents a basic scraper for Labyrinth using WebDriver as engine
    /// </summary>
    public abstract class LabyrinthWebDriverScraperBase : LabyrinthScraperBase
    {
        /// <summary>
        /// The selenium object, not available on WebDriver macros
        /// </summary>
        [Obsolete("WEBDRIVER macros cannot use SELENIUM object", true)]
        protected ISelenium selenium;

        private int clonedWindows = 1;
        private TimeSpan currentWait = IMPLICIT_WAIT;
        protected TimeSpan waitAfterScrolling = TimeSpan.Zero;


        /// <summary>
        /// Initializes a new instance of the <see cref="LabyrinthWebDriverScraperBase"/> class.
        /// </summary>
        /// <param name="anArgument">An argument.</param>
        protected LabyrinthWebDriverScraperBase(string anArgument)
            : base(anArgument)
        {
        }


        /// <summary>
        /// Initializes a new instance of the <see cref="LabyrinthWebDriverScraperBase"/> class.
        /// </summary>
        protected LabyrinthWebDriverScraperBase()
            : base()
        {

        }


        #region LOG SYSTEM


        /// <summary>
        /// Adds the context error.
        /// </summary>
        /// <param name="contextError">The context error.</param>
        public void AddContextError(string contextError)
        {
            // Do some cleansing before sending it back to the server
            driver.AddContextError(contextError.Replace("\r\n", "<br/>").Replace("\r", "").Replace("\n", "<br/>").Replace("\"", "'"));
            Thread.Sleep(1000);
        }


        #endregion LOG SYSTEM


        #region AJAX HELPER METHODS



        /// <summary>
        /// Waits and then get the present element.
        /// </summary>
        /// <param name="by">The by.</param>
        /// <param name="maxSeconds">The maximum seconds.</param>
        /// <returns></returns>
        protected IWebElement WaitAndGetElementPresent(By by, int maxSeconds)
        {
            try
            {
                WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(maxSeconds));
                wait.IgnoreExceptionTypes(typeof(StaleElementReferenceException));
                IWebElement webElement = wait.Until(ExpectedConditions.ElementExists(by));
                return webElement;
            }
            catch
            {
                return null;
            }
        }



        /// <summary>
        /// Waits and then get the visible element.
        /// </summary>
        /// <param name="by">The by.</param>
        /// <param name="maxSeconds">The maximum seconds.</param>
        /// <returns></returns>
        protected IWebElement WaitAndGetElementVisible(By by, int maxSeconds)
        {
            try
            {
                WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(maxSeconds));
                wait.IgnoreExceptionTypes(typeof(StaleElementReferenceException));
                IWebElement webElement = wait.Until(ExpectedConditions.ElementIsVisible(by));
                return webElement;
            }
            catch
            {
                return null;
            }
        }



        /// <summary>Waits and click if element visible.</summary>
        /// <param name="by">The by.</param>
        /// <param name="maxSeconds">The maximum seconds.</param>
        /// <returns>
        ///   <br />
        /// </returns>
        protected bool WaitAndClickElementVisible(By by, int maxSeconds)
        {
            try
            {
                IWebElement webElement = WaitAndGetElementVisible(by, maxSeconds);
                Click(by);
                return true;
            }
            catch
            {
                return false;
            }
        }


      


        /// <summary>
        /// Determines whether [is element present] [the specified by].
        /// </summary>
        /// <param name="by">The by.</param>
        /// <returns></returns>
        protected bool IsElementPresent(By by)
        {
            bool present = false;

            RemoveImplicitWaitBasedOnCurrentSpeed();

            try
            {
                present = driver.FindElement(by) != null;
            }
            catch (NoSuchElementException)
            {
            }

            RestoreImplicitWaitBasedOnCurrentSpeed();

            return present;
        }


        /// <summary>
        /// Determines whether [is element present in children] [the specified by].
        /// </summary>
        /// <param name="by">The by.</param>
        /// <param name="parent">The parent.</param>
        /// <returns></returns>
        protected bool IsElementPresentInChildren(By by, IWebElement parent)
        {
            bool present = false;

            RemoveImplicitWaitBasedOnCurrentSpeed();

            try
            {
                present = parent.FindElement(by) != null;
            }
            catch (NoSuchElementException)
            {
            }

            RestoreImplicitWaitBasedOnCurrentSpeed();

            return present;
        }



        /// <summary>
        /// Determines whether [is element present and visible] [the specified by].
        /// </summary>
        /// <param name="by">The by.</param>
        /// <returns></returns>
        protected bool IsElementPresentAndVisible(By by)
        {
            bool presentAndVisible = false;

            RemoveImplicitWaitBasedOnCurrentSpeed();

            try
            {
                presentAndVisible = driver.FindElement(by).Displayed;
            }
            catch (NoSuchElementException)
            {
            }
            catch (StaleElementReferenceException)
            {
            }

            RestoreImplicitWaitBasedOnCurrentSpeed();

            return presentAndVisible;
        }



        /// <summary>
        /// Determines whether [is element present and visible in children] [the specified by].
        /// </summary>
        /// <param name="by">The by.</param>
        /// <param name="parent">The parent.</param>
        /// <returns></returns>
        protected bool IsElementPresentAndVisibleInChildren(By by, IWebElement parent)
        {
            bool presentAndVisible = false;

            RemoveImplicitWaitBasedOnCurrentSpeed();

            try
            {
                presentAndVisible = parent.FindElement(by).Displayed;
            }
            catch (NoSuchElementException)
            {
            }

            RestoreImplicitWaitBasedOnCurrentSpeed();

            return presentAndVisible;
        }


        /// <summary>
        /// Determines whether [is element present and not visible] [the specified by].
        /// </summary>
        /// <param name="by">The by.</param>
        /// <returns></returns>
        protected bool IsElementPresentAndNotVisible(By by)
        {
            bool presentAndNotVisible = false;

            RemoveImplicitWaitBasedOnCurrentSpeed();

            try
            {
                presentAndNotVisible = !driver.FindElement(by).Displayed;
            }
            catch (NoSuchElementException)
            {
            }

            RestoreImplicitWaitBasedOnCurrentSpeed();

            return presentAndNotVisible;
        }




        /// <summary>
        /// Determines whether [is element present and not visible in children] [the specified by].
        /// </summary>
        /// <param name="by">The by.</param>
        /// <param name="parent">The parent.</param>
        /// <returns></returns>
        protected bool IsElementPresentAndNotVisibleInChildren(By by, IWebElement parent)
        {
            bool presentAndNotVisible = false;

            RemoveImplicitWaitBasedOnCurrentSpeed();

            try
            {
                presentAndNotVisible = !parent.FindElement(by).Displayed;
            }
            catch (NoSuchElementException)
            {
            }

            RestoreImplicitWaitBasedOnCurrentSpeed();

            return presentAndNotVisible;
        }



        /// <summary>
        /// Waits for an Element to be present at the website. Very useful for AJAX websites
        /// </summary>
        /// <param name="elementBy">The element by.</param>
        /// <param name="maxSeconds">The max seconds to wait for the element.</param>
        /// <returns>
        /// true if the element has been found. false in other case
        /// </returns>
        protected bool WaitForElementPresent(By elementBy, int maxSeconds)
        {
            IWebElement webElement = WaitAndGetElementPresent(elementBy, maxSeconds);
            return webElement != null;
        }


        /// <summary>
        /// Waits for element visible.
        /// </summary>
        /// <param name="elementBy">The element by.</param>
        /// <param name="maxSeconds">The max seconds.</param>
        /// <returns>
        /// If the element is finally visible
        /// </returns>
        protected bool WaitForElementVisible(By elementBy, int maxSeconds)
        {
            IWebElement webElement = WaitAndGetElementVisible(elementBy, maxSeconds);
            if (webElement != null)
                return webElement.Displayed;
            else
                return false;
        }


        /// <summary>
        /// Waits for element visible and editable
        /// </summary>
        /// <param name="elementBy">The element by.</param>
        /// <param name="maxSeconds">The max seconds.</param>
        /// <returns>
        /// If the element is finally visible
        /// </returns>
        protected bool WaitForElementVisibleAndEditable(By elementBy, int maxSeconds)
        {
            IWebElement webElement = WaitAndGetElementVisible(elementBy, maxSeconds);
            if (webElement != null)
                return webElement.Displayed && webElement.Enabled;
            else
                return false;
        }




        /// <summary>
        /// Waits for the select field is filled with values. Very useful for AJAX websites
        /// </summary>
        /// <param name="selectFieldBy">The select field by.</param>
        /// <param name="maxSeconds">The max seconds to wait.</param>
        /// <returns>
        /// true if the select field has been filled with values. false in other case
        /// </returns>
        protected bool WaitForSelectFieldFilled(By selectFieldBy, int maxSeconds)
        {
            return WaitForSelectFieldFilled(selectFieldBy, 0, maxSeconds);
        }



        /// <summary>
        /// Waits for select field filled and visible. Very useful for AJAX websites
        /// </summary>
        /// <param name="selectFieldBy">The select field by.</param>
        /// <param name="maxSeconds">The maximum seconds.</param>
        /// <returns></returns>
        protected bool WaitForSelectFieldFilledAndVisible(By selectFieldBy, int maxSeconds)
        {
            return WaitForSelectFieldFilledAndVisible(selectFieldBy, 0, maxSeconds);
        }



        /// <summary>
        /// Waits the and get select field filled and visible.
        /// </summary>
        /// <param name="selectFieldBy">The select field by.</param>
        /// <param name="maxSeconds">The maximum seconds.</param>
        /// <returns></returns>
        protected SelectElement WaitAndGetSelectFieldFilledAndVisible(By selectFieldBy, int maxSeconds)
        {
            IWebElement webElement = WaitAndGetElementVisible(selectFieldBy, maxSeconds);

            if (webElement != null)
            {
                SelectElement select = new SelectElement(webElement);
                if (select.Options.Count > 0)
                    return select;
                else
                    return null;
            }
            else
                return null;
        }



        /// <summary>
        /// Waits the and get select field filled and visible.
        /// </summary>
        /// <param name="selectFieldBy">The select field by.</param>
        /// <param name="minOptions">The minimum options.</param>
        /// <param name="maxSeconds">The maximum seconds.</param>
        /// <returns></returns>
        protected SelectElement WaitAndGetSelectFieldFilledAndVisible(By selectFieldBy, int minOptions, int maxSeconds)
        {
            IWebElement webElement = WaitAndGetElementVisible(selectFieldBy, maxSeconds);

            if (webElement != null)
            {
                SelectElement select = new SelectElement(webElement);
                if (select.Options.Count >= minOptions)
                    return select;
                else
                    return null;
            }
            else
                return null;
        }


        /// <summary>
        /// Waits for the select field is filled with values. Very useful for AJAX websites
        /// </summary>
        /// <param name="selectFieldBy">The select field by.</param>
        /// <param name="minOptions">The min options.</param>
        /// <param name="maxSeconds">The max seconds to wait.</param>
        /// <returns>
        /// true if the select field has been filled with values. false in other case
        /// </returns>
        protected bool WaitForSelectFieldFilled(By selectFieldBy, int minOptions, int maxSeconds)
        {
            IWebElement webElement = WaitAndGetElementPresent(selectFieldBy, maxSeconds);

            if (webElement != null)
                return new SelectElement(webElement).Options.Count > minOptions;
            else
                return false;
        }


        /// <summary>
        /// Waits for select field filled and visible. Very useful for AJAX websites
        /// </summary>
        /// <param name="selectFieldBy">The select field by.</param>
        /// <param name="minOptions">The minimum options.</param>
        /// <param name="maxSeconds">The maximum seconds.</param>
        /// <returns></returns>
        protected bool WaitForSelectFieldFilledAndVisible(By selectFieldBy, int minOptions, int maxSeconds)
        {
            IWebElement webElement = WaitAndGetElementVisible(selectFieldBy, maxSeconds);

            if (webElement != null)
                return new SelectElement(webElement).Options.Count > minOptions;
            else
                return false;
        }



        /// <summary>
        /// Waits for element to disappear. This method assumes the element is already present and visible although it waits 1 seconds to help it showing up
        /// </summary>
        /// <param name="by">The by.</param>
        /// <param name="maxSeconds">The maximum seconds.</param>
        /// <returns>True if the element is not longer present and visible</returns>
        protected bool WaitForElementToDisappear(By by, int maxSeconds)
        {
            Sleep(1000);
            int counter = 0;
            while(IsElementPresentAndVisible(by) && counter < maxSeconds)
            {
                counter++;
                Sleep(1000);
            }

            return !IsElementPresentAndVisible(by);            
        }
        



        /// <summary>Determines whether [is element present and visible and editable] [the specified by].</summary>
        /// <param name="by">The by.</param>
        /// <returns>
        ///   <c>true</c> if [is element present and visible and editable] [the specified by]; otherwise, <c>false</c>.</returns>
        protected bool IsElementPresentAndVisibleAndEditable(By by)
        {
            bool presentAndVisibleAndEditable = false;

            RemoveImplicitWaitBasedOnCurrentSpeed();

            try
            {
                IWebElement element = driver.FindElement(by);
                presentAndVisibleAndEditable = element.Displayed && element.Enabled;                
            }
            catch (NoSuchElementException)
            {
            }

            RestoreImplicitWaitBasedOnCurrentSpeed();

            return presentAndVisibleAndEditable;
        }



        /// <summary>Determines whether [is element present and visible and not editable] [the specified by].</summary>
        /// <param name="by">The by.</param>
        /// <returns>
        ///   <c>true</c> if [is element present and visible and not editable] [the specified by]; otherwise, <c>false</c>.</returns>
        protected bool IsElementPresentAndVisibleAndNotEditable(By by)
        {
            bool presentAndVisibleAndNotEditable = false;

            RemoveImplicitWaitBasedOnCurrentSpeed();

            try
            {
                IWebElement element = driver.FindElement(by);
                presentAndVisibleAndNotEditable = element.Displayed && !element.Enabled;
            }
            catch (NoSuchElementException)
            {
            }

            RestoreImplicitWaitBasedOnCurrentSpeed();

            return presentAndVisibleAndNotEditable;
        }


        #endregion AJAX HELPER METHODS


        #region SELECT HELPER METHODS


        /// <summary>
        /// Finds the select.
        /// </summary>
        /// <param name="selectElementBy">The select element by.</param>
        /// <returns></returns>
        protected SelectElement FindSelect(By selectElementBy)
        {
            return new SelectElement(driver.FindElement(selectElementBy));
        }


        /// <summary>
        /// Gets the select values of a WebDriver Select
        /// </summary>
        /// <param name="selectElementBy">The select element by.</param>
        /// <returns></returns>
        protected string[] GetSelectValues(By selectElementBy)
        {
            return GetSelectValues(new SelectElement(driver.FindElement(selectElementBy)));
        }


        /// <summary>
        /// Gets the select values.
        /// </summary>
        /// <param name="selectElement">The select element.</param>
        /// <returns></returns>
        protected string[] GetSelectValues(SelectElement selectElement)
        {
            int oldSpeed = GetSpeed();
            SetSpeed(0);
            string[] selectValues = new string[selectElement.Options.Count];

            for (int i = 0; i < selectValues.Length; i++)
                selectValues[i] = selectElement.Options[i].GetAttribute("value");

            SetSpeed(oldSpeed);
            return selectValues;
        }


        /// <summary>
        /// Gets the select options.
        /// </summary>
        /// <param name="selectElement">The select element.</param>
        /// <returns></returns>
        protected string[] GetSelectOptions(SelectElement selectElement)
        {
            int oldSpeed = GetSpeed();
            SetSpeed(0);
            string[] selectOptions = new string[selectElement.Options.Count];

            for (int i = 0; i < selectOptions.Length; i++)
                selectOptions[i] = selectElement.Options[i].Text;

            SetSpeed(oldSpeed);
            return selectOptions;
        }


        /// <summary>
        /// Gets the select options.
        /// </summary>
        /// <param name="selectElementBy">The select element by.</param>
        /// <returns></returns>
        protected string[] GetSelectOptions(By selectElementBy)
        {
            return GetSelectOptions(new SelectElement(driver.FindElement(selectElementBy)));
        }



        /// <summary>
        /// Selects by index.
        /// </summary>
        /// <param name="selectElementBy">The select element by.</param>
        /// <param name="indexToMatch">The index to match.</param>
        protected void SelectByIndex(By selectElementBy, int indexToMatch)
        {
            SelectElement selectElement = WaitAndGetSelectFieldFilledAndVisible(selectElementBy, 10);
            selectElement.SelectByIndex(indexToMatch);
        }


        /// <summary>
        /// Selects by label.
        /// </summary>
        /// <param name="selectElementBy">The select element by.</param>
        /// <param name="labelToMatch">The label to match.</param>
        protected void SelectByLabel(By selectElementBy, string labelToMatch)
        {
            SelectElement selectElement = WaitAndGetSelectFieldFilledAndVisible(selectElementBy, 10);
            selectElement.SelectByText(labelToMatch);
        }


        /// <summary>
        /// Selects by value.
        /// </summary>
        /// <param name="selectElementBy">The select element by.</param>
        /// <param name="valueToMatch">The value to match.</param>
        protected void SelectByValue(By selectElementBy, string valueToMatch)
        {
            SelectElement selectElement = WaitAndGetSelectFieldFilledAndVisible(selectElementBy, 10);
            selectElement.SelectByValue(valueToMatch);
        }



        /// <summary>Gets the selected label.</summary>
        /// <param name="selectElementBy">The select element by.</param>
        /// <returns></returns>
        protected string GetSelectedLabel(By selectElementBy)
        {
            SelectElement selectElement = WaitAndGetSelectFieldFilledAndVisible(selectElementBy, 10);
            return selectElement.SelectedOption.Text;
        }


        /// <summary>Gets the selected value.</summary>
        /// <param name="selectElementBy">The select element by.</param>
        /// <returns></returns>
        protected string GetSelectedValue(By selectElementBy)
        {
            SelectElement selectElement = WaitAndGetSelectFieldFilledAndVisible(selectElementBy, 10);
            return selectElement.SelectedOption.GetAttribute("value");
        }



        /// <summary>
        /// Selects the best option in a a select dropdown by label. The best option is calculated using the "GetBestMatchInSelectFieldOptionsForVehicles" standard search method        
        /// Returns the index
        /// </summary>
        /// <param name="selectElementBy"></param>
        /// <param name="labelToMatch"></param>
        /// <returns></returns>
        protected int SelectBestOptionByLabel(By selectElementBy, string labelToMatch)
        {
            return SelectBestOptionByLabel(selectElementBy, labelToMatch, null);
        }



        /// <summary>
        /// Selects the best option in a a select dropdown by label. The best option is calculated using the "GetBestMatchInSelectFieldOptionsForVehicles" standard search method        
        /// Returns the index
        /// </summary>
        /// <param name="selectElementBy">The select element by.</param>
        /// <param name="labelToMatch">The label to match.</param>
        protected int SelectBestOptionByLabel(By selectElementBy, string labelToMatch, string[] textsToRemove = null)
        {
            SelectElement selectElement = WaitAndGetSelectFieldFilledAndVisible(selectElementBy, 10);
            string[] options = CleanOptions(GetSelectOptions(selectElement), textsToRemove);            
            int index = GetBestMatchInSelectFieldOptionsForVehicles(labelToMatch, options);
            selectElement.SelectByIndex(index);
            return index;
        }


        /// <summary>Selects the best numeric option by label (it assumes all labels are numeric values and they are ordered)</summary>
        /// <param name="selectElementBy">The select element by.</param>
        /// <param name="labelToMatch">The label to match.</param>
        /// <returns></returns>
        protected int SelectBestNumericOptionByLabel(By selectElementBy, float labelToMatch)
        {
            return SelectBestNumericOptionByLabel(selectElementBy, labelToMatch, null);
        }


        /// <summary>Selects the best numeric option by label (it assumes all labels are numeric values and they are ordered)</summary>
        /// <param name="selectElementBy">The select element by.</param>
        /// <param name="labelToMatch">The label to match.</param>
        /// <returns></returns>
        protected int SelectBestNumericOptionByLabel(By selectElementBy, float labelToMatch, string[] textsToRemove = null)
        {
            SelectElement selectElement = WaitAndGetSelectFieldFilledAndVisible(selectElementBy, 10);
            string[] options = CleanOptions(GetSelectOptions(selectElement), textsToRemove);
            int index = GetBestMatchBetweenNumericValues(labelToMatch, options);
            selectElement.SelectByIndex(index);
            return index;
        }



        /// <summary>
        /// Selects the best option in a select dropdown by value. The best option is calculated using the "GetBestMatchInSelectFieldOptionsForVehicles" standard search method.        
        /// Returns the index
        /// </summary>
        /// <param name="selectElementBy">The select element by.</param>
        /// <param name="valueToMatch">The value to match.</param>
        protected int SelectBestOptionByValue(By selectElementBy, string valueToMatch)
        {
            return SelectBestOptionByValue(selectElementBy, valueToMatch, null);
        }



        /// <summary>
        /// Selects the best option in a select dropdown by value. The best option is calculated using the "GetBestMatchInSelectFieldOptionsForVehicles" standard search method.        
        /// Returns the index
        /// </summary>
        /// <param name="selectElementBy">The select element by.</param>
        /// <param name="valueToMatch">The value to match.</param>
        protected int SelectBestOptionByValue(By selectElementBy, string valueToMatch, string[] textsToRemove = null)
        {
            SelectElement selectElement = WaitAndGetSelectFieldFilledAndVisible(selectElementBy, 10);
            string[] values = CleanOptions(GetSelectValues(selectElement), textsToRemove);
            int index = GetBestMatchInSelectFieldOptionsForVehicles(valueToMatch, values);
            selectElement.SelectByIndex(index);
            return index;
        }


        /// <summary>Selects the best numeric option by value.
        /// It assumes the values are all numeric and ordered</summary>
        /// <param name="selectElementBy">The select element by.</param>
        /// <param name="valueToMatch">The value to match.</param>
        /// <returns></returns>
        protected int SelectBestNumericOptionByValue(By selectElementBy, float valueToMatch)
        {
            return SelectBestNumericOptionByValue(selectElementBy, valueToMatch, null);
        }


        /// <summary>Selects the best numeric option by value.
        /// It assumes the values are all numeric and ordered</summary>
        /// <param name="selectElementBy">The select element by.</param>
        /// <param name="valueToMatch">The value to match.</param>
        /// <returns></returns>
        protected int SelectBestNumericOptionByValue(By selectElementBy, float valueToMatch, string[] textsToRemove = null)
        {
            SelectElement selectElement = WaitAndGetSelectFieldFilledAndVisible(selectElementBy, 10);
            string[] values = CleanOptions(GetSelectValues(selectElement), textsToRemove);
            int index = GetBestMatchBetweenNumericValues(valueToMatch, values);
            selectElement.SelectByIndex(index);
            return index;
        }



        #endregion SELECT HELPER METHODS


        #region TEXT HELPER METHODS






        /// <summary>
        /// Gets the body text.
        /// </summary>
        /// <returns></returns>
        protected String GetBodyText()
        {
            bool present = false;
            return driver.FindElement(By.TagName("body")).Text;
        }


        /// <summary>
        /// Determines whether [is text present] [the specified text].
        /// </summary>
        /// <param name="text">The text.</param>
        /// <returns></returns>
        protected bool IsTextPresent(String text)
        {
            bool present = false;

            RemoveImplicitWaitBasedOnCurrentSpeed();

            try
            {
                //IWebElement element = driver.FindElement(By.XPath("//*[contains(.,'" + text + "')]"));
                // [21/09/2022] To handle texts with single quote. Eg: ...something's gone wrong here.
                IWebElement element = driver.FindElement(By.XPath($"//*[contains(text(),\"{text}\")]"));
                present = element != null;
            }
            catch
            {
                return present = false;
            }

            RestoreImplicitWaitBasedOnCurrentSpeed();

            return present;
        }

        /// <summary>
        /// Determines whether [is text present and the text node visible] [the specified text].
        /// </summary>
        /// <param name="text">The text.</param>
        /// <returns></returns>
        protected bool IsTextPresentAndVisible(String text)
        {
            bool presentAndVisible = false;

            RemoveImplicitWaitBasedOnCurrentSpeed();

            try
            {
                // [21/09/2022] To handle texts with single quote. Eg: ...something's gone wrong here.
                ReadOnlyCollection<IWebElement> elements = driver.FindElements(By.XPath($"//*[contains(text(),\"{text}\")]"));
                presentAndVisible = elements.Any(c => c.Displayed);

                return presentAndVisible;
            }
            catch
            {
                return presentAndVisible = false;
            }

            RestoreImplicitWaitBasedOnCurrentSpeed();

            return presentAndVisible;
        }

        #endregion TEXT HELPER METHODS


        #region CLONED WINDOWS

        /// <summary>
        /// Creates the cloned window (from the current window).
        /// </summary>
        /// <returns></returns>
        public string CreateClonedWindow()
        {
            try
            {
                // Create a cloned window                
                ((IJavaScriptExecutor)driver).ExecuteScript("var clonedWindow_" + clonedWindows + " = window.open(\"" + driver.Url + "\", \"Cloned Window\", \"width=900, height=400, toolbar=no, scrollbars=yes, resizable=yes\");");
                clonedWindows++;
                return "clonedWindow" + (clonedWindows - 1);
            }
            catch
            {
                return "clonedWindowCouldNotBeCreated";
            }
        }


        /// <summary>
        /// Closes the cloned window.
        /// </summary>
        /// <param name="clonedWindowId">The cloned window identifier.</param>
        /// <param name="newActiveWindow">The new active window.</param>
        public void CloseClonedWindow(string clonedWindowId, string newActiveWindow)
        {
            try
            {
                // Create a cloned window                
                driver.SwitchTo().Window(clonedWindowId).Close();
            }
            catch
            {
            }
            finally
            {
                try
                {
                    driver.SwitchTo().Window(newActiveWindow);
                }
                catch { }
            }
        }


        #endregion CLONED WINDOWS


        #region MISCELLANEOUS


        /// <summary>
        /// Gets the speed (in milliseconds).
        /// </summary>
        /// <returns></returns>
        public int GetSpeed()
        {
            return ((IDelayable)driver).GetDelay();
        }


        /// <summary>
        /// Sets the speed.
        /// </summary>
        /// <param name="speed">The speed.</param>
        public void SetSpeed(int speed)
        {
            ((IDelayable)driver).SetDelay(speed);
        }



        /// <summary>
        /// Determines whether [is alert present].
        /// </summary>
        /// <returns></returns>
        public bool IsAlertPresent()
        {
            try
            {
                driver.SwitchTo().Alert();
                return true;
            }   // try
            catch (NoAlertPresentException Ex)
            {
                return false;
            }   // catch
        }


        /// <summary>
        /// Gets the alert.
        /// </summary>
        /// <returns></returns>
        public String GetAlert()
        {
            IAlert alert = driver.SwitchTo().Alert();
            String str = alert.Text;

            alert.Accept();
            return str;
        }


        /// <summary>
        /// Consumes the alert if present.
        /// </summary>
        public void ConsumeAlertIfPresent()
        {
            try
            {
                driver.SwitchTo().Alert().Accept();
            }
            catch
            {

            }
        }

        /// <summary>
        /// Scroll the window to the element we want
        /// </summary>
        /// <param name="byElement"></param>
        [Obsolete("PLEASE AVOID THIS METHOD. ScrollWindowToElement(By byElement, LocationInWindow location)'", true)]
        protected void ScrollWindowToElement(By byElement)
        {
            int elementLocation = driver.FindElement(byElement).Location.Y;
            RunScript("window.scrollTo(0, " + elementLocation + ");");
        }

        /// <summary>
        /// Where we want see the selected element when scroll the window.
        /// </summary>
        public enum LocationInWindow
        {
            
            TOP,
            MIDDLE,
            BOTTOM
        }


        /// <summary>
        /// Scroll the window to the selected element and setting the location for the element
        /// Method selects middle by default
        /// </summary>
        /// <param name="byElement">The locator</param>
        /// <param name="location">The location we want scroll the window</param>        
        protected void ScrollWindowToElement(By byElement, LocationInWindow location)
        {
            ScrollWindowToElement(driver.FindElement(byElement), location);         
        }



        /// <summary>
        /// Scroll the window to the selected element and setting the location for the element
        /// </summary>
        /// <param name="element"></param>
        /// <param name="location"></param>
        protected void ScrollWindowToElement(IWebElement element, LocationInWindow location)
        {            
            int elementX = element.Location.X;
            int elementY = element.Location.Y;
            int windowHeight = driver.Manage().Window.Size.Height;

            switch (location)
            {
                case LocationInWindow.TOP:
                    elementY -= (windowHeight * 20 / 100);
                    break;
                case LocationInWindow.BOTTOM:
                    elementY -= (windowHeight * 80 / 100);
                    break;
                case LocationInWindow.MIDDLE:
                default:
                    elementY -= (windowHeight * 50 / 100);
                    break;
            }

            try
            {
                //RunScript("window.scrollTo(0, " + elementLocation + ");");
                RunScript("window.scrollTo( { top: " + elementY + ", left: " + elementX + ", behavior: 'smooth' });");
            }
            catch
            {
                // Deal System.InvalidOperationException: javascript error: target.offset is not a function                
                RunScript("window.scrollTo(0, " + elementY + ");");
            }
            finally
            {
                if (waitAfterScrolling != TimeSpan.Zero)
                {
                    Sleep((int)waitAfterScrolling.TotalMilliseconds);
                }
            }
        }

        /// <summary>
        /// Keeps the scroll enable
        /// </summary>
        protected void KeepScroll()
        {
            RunScript("document.body.style.overflow = 'scroll';");

        }




        #endregion


        #region BASIC ACTIONS


        /// <summary>
        /// Clicks the specified by element.
        /// </summary>
        /// <param name="byElement">The by element.</param>
        protected void Click(By byElement)
        {
            if (clickAtAllCosts)
            {
                ClickAtAllCosts(byElement);
            }
            else
            {
                if (IsNextActionWithMouseHovering() || IsMouseHoverOnClickEnabled() || IsMouseHoverOnClickAndTakeScreenshotEnabled())
                    MouseHover(byElement);

                if (IsMouseHoverOnClickAndTakeScreenshotEnabled())
                    TakeScreenShotIfEnabled();

                ScrollWindowToElement(byElement, LocationInWindow.MIDDLE);
                driver.FindElement(byElement).Click();
            }
        }


        /// <summary>Clicks the label for.</summary>
        /// <param name="elementId">The element identifier.</param>
        protected void ClickLabelFor(string elementId)
        {            
            Click(By.CssSelector(string.Format("label[for='{0}']", elementId)));            
        }

        /// <summary>
        /// Check if the label is present and visible
        /// </summary>
        /// <param name="id">The input id or label for att</param>
        /// <returns></returns>
        protected bool IsLabelPresentAndVisible(string id)
        {
            return IsElementPresentAndVisible(By.XPath($"//label[@for='{id}']"));
        }

        /// <summary>
        /// Returns tha xpath for the label
        /// </summary>
        /// <param name="id">The input id or label for att</param>
        /// <returns></returns>
        protected string GetLabelXpath(string id)
        {
            return $"//label[@for='{id}']";
        }



        /// <summary>Clicks at all costs.</summary>
        /// <param name="byElement">The by element.</param>
        protected void ClickAtAllCosts(By byElement)
        {
            RemoveImplicitWaitBasedOnCurrentSpeed();

            IWebElement element = driver.FindElement(byElement);
            object[] args = { element };

            if (element == null)
            {
                AddContextError("Element " + byElement + " not found!");
                RestoreImplicitWaitBasedOnCurrentSpeed();
                return;
            }

            if (element.Displayed && element.Enabled) // Element displayed and ready for click
            {
                try
                {
                    if (IsNextActionWithMouseHovering() || IsMouseHoverOnClickEnabled() || IsMouseHoverOnClickAndTakeScreenshotEnabled())
                        MouseHover(element);

                    if (IsMouseHoverOnClickAndTakeScreenshotEnabled())
                        TakeScreenShotIfEnabled();

                    ScrollWindowToElement(element, LocationInWindow.MIDDLE);
                    element.Click();
                }
                catch (Exception ex) // Normally when the element is obscured or invisible in some form
                {
                    // Finally click using JS
                    RunScriptWithParameters("arguments[0].focus(); arguments[0].click();", args);
                }
            }
            else // Hidden element
            {
                // Try JS first                
                RunScriptWithParameters("arguments[0].focus(); arguments[0].click();", args);
            }

            RestoreImplicitWaitBasedOnCurrentSpeed();

        }





        /// <summary>
        /// Clicks the using js.
        /// </summary>
        /// <param name="byElement">The by element.</param>
        protected void ClickUsingJS(By byElement)
        {
            object[] args = { driver.FindElement(byElement) };
            RunScriptWithParameters("arguments[0].click();", args);
        }

        /// <summary>
        /// Clicks if present.
        /// </summary>
        /// <param name="byElement">The by element.</param>
        protected void ClickIfPresent(By byElement)
        {            
            if (IsElementPresent(byElement))
                Click(byElement);
        }



        /// <summary>
        /// Clicks if present and visible.
        /// </summary>
        /// <param name="byElement">The by element.</param>
        protected void ClickIfPresentAndVisible(By byElement)
        {
            if (IsElementPresentAndVisible(byElement))
                Click(byElement);
        }



        /// <summary>
        /// Clears the input.
        /// </summary>
        /// <param name="by">The by.</param>
        protected void ClearInput(By by)
        {
            ClearInput(driver.FindElement(by));
        }

        /// <summary>
        /// Clears the input.
        /// </summary>
        /// <param name="element">The element.</param>
        protected void ClearInput(IWebElement element)
        {
            element.Click();
            element.Clear();
            element.SendKeys(Keys.Control + "A");
            element.SendKeys(Keys.Backspace);
        }



        /// <summary>
        /// Types into the specified by element.
        /// </summary>
        /// <param name="by">The by element.</param>
        /// <param name="text">The text.</param>
        protected void Type(By by, String text)
        {            
            ScrollWindowToElement(by, LocationInWindow.MIDDLE);

            if (IsNextActionWithMouseHovering())
                MouseHover(by);

            IWebElement inputElement = driver.FindElement(by);
            ClearInput(inputElement);

            if (IsBehaviouralBotEnabled())
            {
                if (IsNextActionAnIntentionalMistake())
                    TypeWithSpeedSettingAndRandomMistakes(by, text, 200);
                else
                    TypeWithSpeedSetting(by, text, 200);
            }
            else
                inputElement.SendKeys(text);
        }


        /// <summary>
        /// Types if present.
        /// </summary>
        /// <param name="byElement">The by element.</param>
        /// <param name="text">The text.</param>
        protected void TypeIfPresent(By byElement, String text)
        {
            if (IsElementPresent(byElement))
                Type(byElement, text);
        }


        /// <summary>
        /// Types if present and visible.
        /// </summary>
        /// <param name="byElement">The by element.</param>
        /// <param name="text">The text.</param>
        protected void TypeIfPresentAndVisible(By byElement, String text)
        {
            if (IsElementPresentAndVisible(byElement))
                Type(byElement, text);
        }



        /// <summary>
        /// For inputs that require a focus to trigger some events this method is quite helpful
        /// </summary>
        /// <param name="byElement">The by element.</param>
        /// <param name="text">The text.</param>
        protected void TypeWithFocus(By byElement, String text)
        {
            Type(byElement, text);
            driver.SwitchTo().Window(driver.CurrentWindowHandle);
        }

        /// <summary>
        /// For inputs that require a blur to trigger some events this method is quite helpful
        /// </summary>
        /// <param name="byElement">The by element.</param>
        /// <param name="text">The text.</param>
        protected void TypeWithBlur(By byElement, String text)
        {
            Type(byElement, text);
            SimulateBlurEvent();
        }

        /// <summary>
        /// For inputs that require a focus to trigger some events this method is quite helpful. Only when element is present
        /// </summary>
        /// <param name="byElement">The by element.</param>
        /// <param name="text">The text.</param>
        protected void TypeWithFocusIfPresent(By byElement, String text)
        {
            if (IsElementPresent(byElement))
            {
                Type(byElement, text);
                driver.SwitchTo().Window(driver.CurrentWindowHandle);
            }
        }


        /// <summary>
        /// For inputs that require a focus to trigger some events this method is quite helpful. Only when element is present and visible.
        /// </summary>
        /// <param name="byElement">The by element.</param>
        /// <param name="text">The text.</param>
        protected void TypeWithFocusIfPresentAndVisible(By byElement, String text)
        {
            if (IsElementPresentAndVisible(byElement))
            {
                Type(byElement, text);
                driver.SwitchTo().Window(driver.CurrentWindowHandle);
            }
        }

        /// <summary>
        /// For inputs that require a specific typing speed.
        /// Very useful for inputs which loading list while we type the text and we need decrease the typing speed. 
        /// </summary>
        /// <param name="byElement">The by element.</param>
        /// <param name="text">The text.</param>
        /// <param name="speed">The typing speed</param>
        protected void TypeWithSpeedSetting(By byElement, string text, int speed)
        {
            string[] textArray = text.ToCharArray().Select(c => c.ToString()).ToArray();
            IWebElement input = driver.FindElement(byElement);
            var old = GetSpeed();

            input.Click();
            input.Clear();

            foreach (var c in textArray)
            {
                SetSpeed(new Random().Next((int)0.75 * speed, (int)1.5 * speed));

                input.SendKeys(c);
            }

            SetSpeed(old);
        }

        /// <summary>
        /// For inputs that require a specific typing speed.
        /// Very useful for inputs which loading list while we type the text and we need decrease the typing speed. 
        /// </summary>
        /// <param name="input">The IWebElement.</param>
        /// <param name="text">The text.</param>
        /// <param name="speed">The typing speed</param>
        protected void TypeWithSpeedSetting(IWebElement input, string text, int speed)
        {
            string[] textArray = text.ToCharArray().Select(c => c.ToString()).ToArray();
            var old = GetSpeed();

            input.Click();
            input.Clear();

            foreach (var c in textArray)
            {
                SetSpeed(new Random().Next((int)0.75 * speed, (int)1.5 * speed));

                input.SendKeys(c);
            }

            SetSpeed(old);
        }



        /// <summary>
        /// Types the with speed setting and random mistakes.
        /// </summary>
        /// <param name="byElement">The by element.</param>
        /// <param name="text">The text.</param>
        /// <param name="speed">The speed.</param>
        private void TypeWithSpeedSettingAndRandomMistakes(By byElement, string text, int speed)
        {
            char[] textArray = text.ToCharArray();
            IWebElement input = driver.FindElement(byElement);
            var old = GetSpeed();
            int count = 0;

            foreach (char c in textArray)
            {
                SetSpeed(new Random().Next( (int) 0.75 * speed, (int) 1.5 * speed));

                if (count == 0)
                {
                    TypeMistakeAndCorrect(input, c);
                    count++;
                }
                else
                {
                    if (IsNextActionAnIntentionalMistake())
                        TypeMistakeAndCorrect(input, c);
                    else
                        input.SendKeys(c.ToString());
                }
            }

            SetSpeed(old);
        }


        /// <summary>
        /// Types the mistake and then correct.
        /// </summary>
        /// <param name="input">The element.</param>
        /// <param name="c">The c.</param>
        private void TypeMistakeAndCorrect(IWebElement input, char c)
        {
            // Mistake
            string typo = RandomStringsBuilder.RandomCloseAlphanumeric(c);
            AddContextInfo($"<span class='btn btn-warning'>WARNING: BEHAVIOUR BOT MAKING A TYPO FROM '{c}' TO '{typo}'</span>");
            input.SendKeys(typo);
            Sleep(new Random().Next(BEHAVIOUR_MISTAKE_MIN_WAIT, BEHAVIOUR_MISTAKE_MAX_WAIT / 4));
            
            // Correction
            input.SendKeys(Keys.Backspace);            
            Sleep(new Random().Next(BEHAVIOUR_MISTAKE_MIN_WAIT, BEHAVIOUR_MISTAKE_MAX_WAIT / 5));
            input.SendKeys(c.ToString());
        }



        /// <summary>
        /// Types the using js.
        /// </summary>
        /// <param name="byElement">The by element.</param>
        /// <param name="text">The text.</param>
        protected void TypeUsingJS(By byElement, string text)
        {
            object[] args = { driver.FindElement(byElement) };
            RunScriptWithParameters("arguments[0].value = '" + text + "';", args);
        }



        /// <summary>
        /// Determines whether the specified by element is checked.
        /// </summary>
        /// <param name="byElement">The by element.</param>
        /// <returns></returns>
        protected bool IsChecked(By byElement)
        {
            return driver.FindElement(byElement).Selected;
        }



        /// <summary>
        /// Checks if not checked.
        /// </summary>
        /// <param name="byElement">The by element.</param>
        protected void CheckIfNotChecked(By byElement)
        {
            IWebElement checkElement = driver.FindElement(byElement);

            if (!checkElement.Selected)
                checkElement.Click();
        }


        /// <summary>Unchecks if checked.</summary>
        /// <param name="byElement">The by element.</param>
        protected void UncheckIfChecked(By byElement)
        {
            IWebElement checkElement = driver.FindElement(byElement);

            if (checkElement.Selected)
                checkElement.Click();
        }



        /// <summary>
        /// Gets the text.
        /// </summary>
        /// <param name="byElement">The by element.</param>
        /// <returns></returns>
        protected String GetText(By byElement)
        {
            return driver.FindElement(byElement).Text;
        }


        /// <summary>
        /// Gets the attribute.
        /// </summary>
        /// <param name="byElement">The by element.</param>
        /// <param name="attribute">The attribute.</param>
        /// <returns></returns>
        protected String GetAttribute(By byElement, String attribute)
        {
            return driver.FindElement(byElement).GetAttribute(attribute);
        }


        /// <summary>Gets the text if present.</summary>
        /// <param name="byElement">The by element.</param>
        /// <returns></returns>
        protected String GetTextIfPresent(By byElement)
        {
            IWebElement element = WaitAndGetElementPresent(byElement, 1);
            if (element != null)
                return element.Text;
            else
                return "";
        }


        /// <summary>Gets the attribute if present.</summary>
        /// <param name="byElement">The by element.</param>
        /// <param name="attribute">The attribute.</param>
        /// <returns></returns>
        protected String GetAttributeIfPresent(By byElement, String attribute)
        {
            IWebElement element = WaitAndGetElementPresent(byElement, 1);
            if (element != null) ccuusu
                return element.GetAttribute(attribute);
            else
                return "";
        }


        /// <summary>Gets the text if present and not visible.</summary>
        /// <param name="byElement">The by element.</param>
        /// <returns></returns>
        protected String GetTextIfPresentAndNotVisible(By byElement)
        {
            object[] args = { driver.FindElement(byElement) };
            return ((IJavaScriptExecutor)driver).ExecuteScript("return arguments[0].innerText;", args).ToString();
        }





        /// <summary>
        /// Runs the script.
        /// </summary>
        /// <param name="script">The script.</param>
        protected void RunScript(String script)
        {
            ((IJavaScriptExecutor)driver).ExecuteScript(script);
        }


        /// <summary>
        /// Runs the script with parameters.
        /// </summary>
        /// <param name="script">The script.</param>
        /// <param name="args">The arguments.</param>
        protected void RunScriptWithParameters(String script, object[] args)
        {
            ((IJavaScriptExecutor)driver).ExecuteScript(script, args);
        }

        /// <summary>
        /// Simulates the blur event on Active element
        /// </summary>
        protected void SimulateBlurEvent()
        {
            driver.SwitchTo().ActiveElement().SendKeys(Keys.Tab);
        }

        /// <summary>
        /// Returns the first visible and enable element. Useful when there are several elements with same locator
        /// </summary>
        /// <param name="byElement">The by element</param>
        /// <returns></returns>
        protected IWebElement GetFirstVisibleAndEnableElement(By byElement)
        {
            var a = driver.FindElements(byElement);

            return a.First(c => c.Displayed && c.Enabled);
        }

        /// <summary>
        /// Click the first visible and enable element. Useful when there are several elements with same locator
        /// </summary>
        /// <param name="byElement"></param>
        protected void ClickFirstVisibleAndEnableElement(By byElement)
        {
            var a = driver.FindElements(byElement);

            a.First(c => c.Displayed && c.Enabled).Click();
        }

        #endregion BASIC ACTIONS



        #region IMPLICIT WAITS TO MAKE WEB DRIVER FASTER

        /// <summary>
        /// Removes the implicit wait based on current speed.
        /// </summary>
        private void RemoveImplicitWaitBasedOnCurrentSpeed()
        {
            if (!currentWait.Equals(NO_WAIT))
            {
                currentWait = NO_WAIT;
                driver.Manage().Timeouts().ImplicitWait = currentWait;
            }
        }


        /// <summary>
        /// Restores the implicit wait based on current speed.
        /// </summary>
        private void RestoreImplicitWaitBasedOnCurrentSpeed()
        {
            if (GetSpeed() > 0)
            {
                if (!currentWait.Equals(IMPLICIT_WAIT))
                {
                    currentWait = IMPLICIT_WAIT;
                    driver.Manage().Timeouts().ImplicitWait = currentWait;
                }                    
            }
        }

        #endregion


        #region MOUSE ACTIONS


        /// <summary>
        /// Drags and drop.
        /// </summary>
        /// <param name="from">From.</param>
        /// <param name="to">To.</param>
        protected void DragAndDrop(IWebElement from, IWebElement to)
        {
            Actions builder = new Actions(driver);
            builder.DragAndDrop(from, to)
                   .Build()
                   .Perform();
        }


        /// <summary>
        /// Drags and drop using Javascript.
        /// </summary>
        /// <param name="from">From.</param>
        /// <param name="to">To.</param>
        protected void DragAndDropUsingJS(IWebElement from, IWebElement to)
        {
            object [] parameters = { from, to };
            RunScriptWithParameters(
                       "function createEvent(typeOfEvent) {\n" + "var event =document.createEvent(\"CustomEvent\");\n"
                    + "event.initCustomEvent(typeOfEvent,true, true, null);\n" + "event.dataTransfer = {\n" + "data: {},\n"
                    + "setData: function (key, value) {\n" + "this.data[key] = value;\n" + "},\n"
                    + "getData: function (key) {\n" + "return this.data[key];\n" + "}\n" + "};\n" + "return event;\n"
                    + "}\n" + "\n" + "function dispatchEvent(element, event,transferData) {\n"
                    + "if (transferData !== undefined) {\n" + "event.dataTransfer = transferData;\n" + "}\n"
                    + "if (element.dispatchEvent) {\n" + "element.dispatchEvent(event);\n"
                    + "} else if (element.fireEvent) {\n" + "element.fireEvent(\"on\" + event.type, event);\n" + "}\n"
                    + "}\n" + "\n" + "function simulateHTML5DragAndDrop(element, destination) {\n"
                    + "var dragStartEvent =createEvent('dragstart');\n" + "dispatchEvent(element, dragStartEvent);\n"
                    + "var dropEvent = createEvent('drop');\n"
                    + "dispatchEvent(destination, dropEvent,dragStartEvent.dataTransfer);\n"
                    + "var dragEndEvent = createEvent('dragend');\n"
                    + "dispatchEvent(element, dragEndEvent,dropEvent.dataTransfer);\n" + "}\n" + "\n"
                    + "var source = arguments[0];\n" + "var destination = arguments[1];\n"
                    + "simulateHTML5DragAndDrop(source,destination);",
                       parameters
                    );

        }


        /// <summary>
        /// Hover the mouse at the element
        /// </summary>
        /// <param name="by">The by.</param>
        protected void MouseHover(By by)
        {
            MouseHover(driver.FindElement(by));
        }


        /// <summary>
        /// Mouses the hover.
        /// </summary>
        /// <param name="element">The element.</param>
        protected void MouseHover(IWebElement element)
        {            
            Actions actions = new Actions(driver);
            actions.MoveToElement(element).Perform();
        }



        /// <summary>
        /// Mouses the hover and click.
        /// </summary>
        /// <param name="byFrom">The by from.</param>
        /// <param name="byTo">The by to.</param>
        protected void MouseHoverAndClick(By byFrom, By byTo)
        {
            MouseHoverAndClick(driver.FindElement(byFrom), driver.FindElement(byTo));
        }


        /// <summary>
        /// Mouses the hover and click.
        /// </summary>
        /// <param name="from">From.</param>
        /// <param name="to">To.</param>
        protected void MouseHoverAndClick(IWebElement from, IWebElement to)
        {
            Actions actions = new Actions(driver);
            actions.MoveToElement(from).MoveToElement(to).Click().Build().Perform();
        }


        #endregion


        #region SET OF METHODS TO MANAGE IFRAMES FOR WEBDRIVER

        /// <summary>
        /// Method to handle iframes according used browser
        /// </summary>
        /// <param name="iframe">The Iframe(string) name or ID </param>
        /// <param name="action">The method which contains the actions we want to do into the iframe</param>
        protected void ManageIframe(string iframe, Action action)
        {
            IWebElement element;
            try
            {
                element = driver.FindElement(By.Id(iframe));
            }
            catch
            {
                element = driver.FindElement(By.Name(iframe));
            }

            WaitForIframeVisible(element, 10);
            SwitchAndDoStuff(element, action);
        }

        /// <summary>
        /// Method to handle iframes according used browser
        /// </summary>
        /// <param name="iframe">The Iframe, its (int) index [zero-base]</param>
        /// <param name="action">The method which contains the actions we want to do into the iframe</param>
        protected void ManageIframe(int iframe, Action action)
        {
            IWebElement element = driver.FindElements(By.TagName("iframe"))[iframe];

            WaitForIframeVisible(driver.FindElements(By.TagName("iframe"))[iframe], 10);
            SwitchAndDoStuff(element, action);
        }

        /// <summary>
        /// Method to handle iframes according used browser
        /// </summary>
        /// <param name="iframe">The frameElement </param>
        /// <param name="action">The method which contains the actions we want to do into the iframe</param>
        protected void ManageIframe(IWebElement iframe, Action action)
        {
            WaitForIframeVisible(iframe, 10);
            SwitchAndDoStuff(iframe, action);
        }

        /// <summary>
        /// Method to switch to the iframe and execute the action
        /// </summary>
        /// <param name="iframe"></param>
        /// <param name="action"></param>
        private void SwitchAndDoStuff(IWebElement iframe, Action action)
        {
            // Switch to the iframe
            driver.SwitchTo().Frame(iframe);

            // Do stuff into the iframe
            action();

            // Switch to parent frame
            switch (driver.GetBrowser())
            {
                case Browser.CHROME:
                    driver.SwitchTo().ParentFrame();
                    break;
                case Browser.FIREFOX:
                default: // we don't know which method works fine with other browsers yet
                    driver.SwitchTo().Frame(0);
                    break;
            }

            Sleep(2000);
        }

        /// <summary>
        /// Wait for IWebElement
        /// </summary>
        /// <param name="element"></param>
        /// <param name="maxSeconds"></param>
        private void WaitForIframeVisible(IWebElement element, int maxSeconds)
        {
            int count = 0;
            do
            {
                Sleep(1000);
                count++;
            }
            while (!element.Displayed && (count < maxSeconds));
        }

        #endregion



        #region ANTICAPTCHA






        /// <summary>
        /// Determines whether [is google captcha detected].
        /// </summary>
        /// <returns>
        ///   <c>true</c> if [is google captcha detected]; otherwise, <c>false</c>.
        /// </returns>
        protected bool IsGoogleCaptchaDetected()
        {
            if (WaitForElementPresent(By.XPath("//div[contains(@class, 'antigate_solver recaptcha')]"), 10))
            {
                AddContextInfo("Captcha Detected!");
                return true;
            }
            else
            {
                AddContextError("Captcha not detected");
                return false;
            }
        }



        /// <summary>
        /// Determines whether [is google captcha being resolved].
        /// </summary>
        /// <returns>
        ///   <c>true</c> if [is google captcha being resolved]; otherwise, <c>false</c>.
        /// </returns>
        protected bool IsGoogleCaptchaBeingResolved()
        {
            if (WaitForElementPresent(By.XPath("//div[@class='antigate_solver recaptcha in_process']"), 10))
            {
                AddContextInfo("Captcha being resolved!");
                return true;
            }
            else
            {
                AddContextError("Unknown status of captcha!");
                return false;
            }
        }


        /// <summary>
        /// Determines whether [is google captcha resolved].
        /// </summary>
        /// <returns>
        ///   <c>true</c> if [is google captcha resolved]; otherwise, <c>false</c>.
        /// </returns>
        protected bool IsGoogleCaptchaResolved()
        {
            if (WaitForElementPresent(By.XPath("//div[@class='antigate_solver recaptcha solved']"), 10))
            {
                AddContextInfo("Captcha Resolved!");
                return true;
            }
            else
            {
                AddContextError("Captcha not resolved yet!");
                return false;
            }
        }



        /// <summary>
        /// Waits for captcha to be resolved.
        /// </summary>
        /// <returns></returns>
        protected bool WaitForGoogleCaptchaToBeResolved()
        {
            AddContextInfo("Waiting for Captcha to be solved");
            if (WaitForElementPresent(By.XPath("//div[@class='antigate_solver recaptcha solved']"), 240))
            {
                AddContextInfo("Yey Captcha has been resolved!");
                return true;
            }
            else
            {
                AddContextError("Unfortunately captcha could not be resolved");
                return false;
            }
        }



        /// <summary>
        /// Waits for google captcha to be resolved.
        /// </summary>
        /// <param name="maxSeconds">The maximum seconds.</param>
        /// <returns></returns>
        protected bool WaitForGoogleCaptchaToBeResolved(int maxSeconds)
        {
            AddContextInfo("Waiting for Captcha to be solved");
            if (WaitForElementPresent(By.XPath("//div[@class='antigate_solver recaptcha solved']"), maxSeconds))
            {
                AddContextInfo("Yey Captcha has been resolved!");
                return true;
            }
            else
            {
                AddContextError("Unfortunately captcha could not be resolved");
                return false;
            }
        }




        /// <summary>
        /// Resolves the automatic google captcha version2.
        /// </summary>
        protected void ResolveAutomaticGoogleCaptchaVersion2()
        {
            Sleep(5000);

            if (IsGoogleCaptchaBeingResolved())
                WaitForGoogleCaptchaToBeResolved();
        }




        /// <summary>
        /// Resolves the automatic google captcha version2.
        /// </summary>
        /// <param name="maxSeconds">The maximum seconds.</param>
        protected void ResolveAutomaticGoogleCaptchaVersion2(int maxSeconds)
        {
            Sleep(5000);

            if (IsGoogleCaptchaBeingResolved())
                WaitForGoogleCaptchaToBeResolved(maxSeconds);
        }




        /// <summary>
        /// Resolves the google captcha version2 on a manual way
        /// </summary>
        protected void ResolveVisibleGoogleCaptchaVersion2()
        {
            // Google captcha present
            if (IsElementPresentAndVisible(By.XPath("//div[@class='g-recaptcha']")) ||
                IsElementPresentAndVisible(By.XPath("//iframe[contains(@src, 'recaptcha/api2')]")))
            {
                AddContextInfo("Resolving Google Recaptcha Version 2");

                driver.SwitchTo().Frame(driver.FindElement(By.XPath("//iframe[contains(@src, 'recaptcha/api2')]")));
                ClickAtAllCosts(By.XPath("//div[@class='recaptcha-checkbox-border']")); // Click on the captcha   
                Sleep(3000);

                // Seems anticaptcha has problems when challenge image is not displayed
                RunScript("var img = document.getElementById('rc-imageselect-target'); if (img == null) { document.getElementsByClassName('recaptcha-checkbox-border')[0].click(); }");
                driver.SwitchTo().ParentFrame();

                // Try to lose focus
                if (WaitForGoogleCaptchaToBeResolved())
                {
                    try
                    {
                        ClickAtAllCosts(By.XPath("//div[@class='antigate_solver recaptcha solved']"));

                        // Clean the challenge panel
                        string captchaXpath = "//iframe[contains(@src, 'recaptcha/api2')]/ancestor::div[contains(@style,'background-color: rgb(255, 255, 255);')]";

                        if (IsElementPresentAndVisible(By.XPath(captchaXpath)))
                        {
                            captchaXpath = captchaXpath.Replace("\'", "\\\"");

                            string script =
                                $"document.evaluate('{captchaXpath}', document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue.style.display = 'none';";

                            RunScript(script);
                        }
                    }
                    catch (Exception ex)
                    {
                        AddContextError("Error while losing focus on Captcha panel: " + ex.ToString());
                    }
                }                 
            }
            else
                AddContextInfo("Google Captcha Version 2 not found");
        }



        /// <summary>
        /// Resolves the google captcha version2.
        /// </summary>
        /// <param name="websiteURL">The website URL.</param>
        /// <param name="websiteKey">The website key.</param>        
        /// <returns></returns>
        [Obsolete("PLEASE AVOID THIS METHOD", true)]
        private String ResolveGoogleCaptchaVersion2(String websiteURL, String websiteKey)
        {
            ServicePointManager.Expect100Continue = true;
            ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;

            string captchaResponse = "";

            var api = new NoCaptchaProxyless
            {
                ClientKey = ANTICAPTCHA_API_KEY,
                WebsiteUrl = new Uri(websiteURL),
                WebsiteKey = websiteKey,
            };

            if (!api.CreateTask())
                AddContextInfo("ERROR: API v2 send failed. " + api.ErrorMessage);
            else if (!api.WaitForResult())
                AddContextInfo("ERROR: Could not solve the captcha.");
            else
            {
                captchaResponse = api.GetTaskSolution().GRecaptchaResponse;
                AddContextInfo("Google Captcha Result: " + captchaResponse);
            }

            return captchaResponse;
        }


        /// <summary>
        /// Resolves the google captcha version3.
        /// </summary>
        /// <param name="websiteURL">The website URL.</param>
        /// <param name="websiteKey">The website key.</param>
        /// <param name="pageAction">The page action (optional)</param>
        /// <returns>
        /// The google captcha response from version 3
        /// </returns>
        [Obsolete("PLEASE AVOID THIS METHOD", true)]
        private String ResolveGoogleCaptchaVersion3(String websiteURL, String websiteKey, string pageAction = null)
        {
            ServicePointManager.Expect100Continue = true;
            ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;

            string captchaResponse = "";

            var api = new RecaptchaV3Proxyless
            {
                ClientKey = ANTICAPTCHA_API_KEY,
                WebsiteUrl = new Uri(websiteURL),
                WebsiteKey = websiteKey,
                PageAction = pageAction != null ? pageAction : ""
            };

            if (!api.CreateTask())
                AddContextInfo("ERROR: API v2 send failed. " + api.ErrorMessage);
            else if (!api.WaitForResult())
                AddContextInfo("ERROR: Could not solve the captcha.");
            else
            {
                captchaResponse = api.GetTaskSolution().GRecaptchaResponse;
                AddContextInfo("Google Captcha Result: " + captchaResponse);
            }

            return captchaResponse;
        }


        #endregion


        #region MANAGE STALE ELEMENT EXCEPTION

        /// <summary>
        /// Method to manage stale element exception
        /// </summary>
        /// <param name="action">Action to execute</param>
        /// <param name="times">Times to try</param>
        protected void ManageStaleElementException(Action action, int times)
        {
            bool done = false;
            int count = 0;

            while (done.Equals(false) && count < times)
            {
                try
                {
                    action.Invoke();
                    done = true;
                }
                catch (Exception e)
                {
                    if (e.GetType().Name.Equals("StaleElementReferenceException"))
                    {
                        Sleep(1000);
                        count++;
                    }
                    else
                    {
                        throw new Exception();
                    }
                }
            }
        }

        #endregion


        #region SET OF ELEMENTS HELPER METHODS


        /// <summary>
        /// Waits for all elements of a list and their texts
        /// </summary>
        /// <param name="locator">The common locator for the list elements</param>
        /// <param name="maxTime">Max waiting time</param>
        protected void WaitForAllListElements(By locator, int maxTime)
        {
            int timeCount = 0;
            int previousCount = -1;
            ReadOnlyCollection<IWebElement> listElements;

            // Wait for the first element of the list
            WaitForElementVisible(locator, 5);

            // The list of elements
            listElements = driver.FindElements(locator);

            while ((listElements.Count != previousCount ||
                listElements.Select(c => c.Text).ToList().Any(t => string.IsNullOrEmpty(t))) &&
                timeCount <= maxTime)
            {
                Sleep(1000);
                previousCount = listElements.Count;
                listElements = driver.FindElements(locator);
                timeCount++;
            }
        }

        /// <summary>
        /// Waits for all elements of a list and gets an array with the text from all the web elements with same locator
        /// </summary>
        /// <param name="locator">The locator</param>
        /// <param name="textsToReplace">The text we want to remove to clean the options</param>
        /// <returns></returns>
        protected string[] GetTextOptionsFromElements(By locator, string[] textsToReplace = null)
        {
            WaitForAllListElements(locator, 10);

            var webElements = driver.FindElements(locator);

            // Get all the text options from the IWebElements
            var options = webElements.Select(c => c.Text);
            options = CleanOptions(options.ToArray(), textsToReplace);
            return options.ToArray();
        }



        /// <summary>
        /// Clean the options on a list
        /// </summary>
        /// <param name="options"></param>
        /// <param name="textsToReplace"></param>
        /// <returns></returns>
        protected string[] CleanOptions(string [] options, string[] textsToReplace = null)
        {
            IEnumerable<string> replacedOptions = options;

            if (textsToReplace != null)
            {
                // Clean the text options 
                foreach (var text in textsToReplace)
                {
                    replacedOptions = replacedOptions.Select(c => c.Replace(text, "").Trim());
                }
            }

            return replacedOptions.ToArray();

        }


        /// <summary>
        /// Click the best option from all the web elements with same locator
        /// </summary>
        /// <param name="locator">The locator</param>
        /// <param name="textToFind">The text to find</param>
        /// <param name="textsToRemove">The text we want to remove to clean the options</param>
        /// <returns></returns>
        protected int ClickBestOptionFromElements(By locator, string textToFind, string[] textsToRemove = null)
        {
            // Get the array of options
            var options = GetTextOptionsFromElements(locator, textsToRemove);

            // Get the best match
            int match = GetBestMatchInSelectFieldOptionsForVehicles(textToFind, options);

            // Click the button
            driver.FindElements(locator)[match].Click();
            
            return match;
        }

        /// <summary>
        /// Click the best numeric option from all the web elements with same locator. This algorithm assumes the option values are ordered
        /// </summary>
        /// <param name="locator">The locator</param>
        /// <param name="value">The value to find</param>
        /// <param name="textsToRemove">The text we want to remove to clean the options</param>
        /// <returns></returns>
        protected int ClickBestNumericOptionFromElements(By locator, string value, string[] textsToRemove = null)
        {
            // Get the array of options
            var options = GetTextOptionsFromElements(locator, textsToRemove);

            // Get the best match
            int match = GetBestMatchBetweenNumericValues(float.Parse(value), options);

            // Click the button
            driver.FindElements(locator)[match].Click();
            return match;
        }

        /// <summary>
        /// Click the exact option (if available) from all the web elements with same locator
        /// </summary>
        /// <param name="locator">The locator</param>
        /// <param name="textToFind">The text to find</param>
        /// <param name="textsToRemove">The text we want to remove to clean the options</param>
        /// <returns>True if textToFind matches with any option</returns>
        protected bool ClickExactOptionFromElements(By locator, string textToFind, string[] textsToRemove = null)
        {
            // Get the array of options
            var options = GetTextOptionsFromElements(locator, textsToRemove);

            // Search the exact 
            int match = options.ToList().FindIndex(c => c.Equals(textToFind));

            // There is not exact match
            if (match.Equals(-1) || !driver.FindElements(locator)[match].Enabled)
            {
                return false;
            }

            // Click the button
            driver.FindElements(locator)[match].Click();
            return true;
        }


        /// <summary>
        /// Sets the attribute.
        /// </summary>
        /// <param name="element">The element.</param>
        /// <param name="attr">The attribute.</param>
        /// <param name="value">The value.</param>
        /// <returns></returns>
        protected void SetAttribute(IWebElement element, String attr, String value)
        {
            RunScriptWithParameters($"arguments[0].setAttribute('{attr}', '{value}');", new object[] { element });
        }


        /// <summary>
        /// Sets the attribute.
        /// </summary>
        /// <param name="by">The by.</param>
        /// <param name="attr">The attribute.</param>
        /// <param name="value">The value.</param>
        protected void SetAttribute(By by, String attr, String value)
        {
            SetAttribute(driver.FindElement(by), attr, value);
        }


        /// <summary>
        /// Removes the attribute.
        /// </summary>
        /// <param name="element">The element.</param>
        /// <param name="attr">The attribute.</param>
        protected void RemoveAttribute(IWebElement element, String attr)
        {
            RunScriptWithParameters($"arguments[0].removeAttribute('{attr}');", new object[] { element });
        }


        /// <summary>
        /// Removes the attribute.
        /// </summary>
        /// <param name="by">The by.</param>
        /// <param name="attr">The attribute.</param>
        protected void RemoveAttribute(By by, String attr)
        {
            RemoveAttribute(driver.FindElement(by), attr);
        }

        /// <summary>
        /// Iterates through a list of elements using only the keyboard, upon finding an exact match in the text, it selects it using Enter.       
        /// Returns if an element has been found
        /// </summary>
        /// <param name="commonLocator">The common locator of the list elements.</param>
        /// <param name="textToFind">The text to match.</param>
        /// <returns></returns>
        protected bool KeyboardSelect(string textToFind, IWebElement[] commonLocator)
        {
            commonLocator[0].SendKeys(Keys.ArrowDown); // To focus the first element

            foreach (var e in commonLocator)
            {
                if (e.Text.Equals(textToFind))
                {
                    e.SendKeys(Keys.Enter);
                    return true;
                }
                e.SendKeys(Keys.ArrowDown);
            }
            return false;
        }


        #endregion

    }
}
